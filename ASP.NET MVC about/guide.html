<html>
<head><meta charset="UTF-8">

<style>body{font-size:1.5em; padding:20px;}section{border:1px solid black; padding:10px;margin-bottom :20px;}img{width:100%;}</style>
</head>
<body>
<section>

<h1>ASP.NET MVC</h1>
<p>MVC is an architectural pattern that stands for Model View Controller. Designed in 1970s and was widely adopted in web. It is used 
by many frameworks like Laravel, RubyOnRails,ASP.NET MVC etc.
 </p>
 
 <ul>
 <li><h2>Model</h2>Application data and behaviour in terms of its problem domain independent of the UI. In model we have our classes.
 These classes have properties and methods that purely represent the application state and rules that have nothing to do with the UI.(Plain CLR objects or POCOs)</li>
 <li><h2>View</h2>The HTML that we display to the user</li>
 <li><h2>Controller</h2> Responsible for handling the HTTP request(for example if our app is hosted in vidly.com and we want to view vidly.com/movies a controller will
 be selected to handle this request)<br>***View <- Controller -> Model*** So the controller is responsible for connecting the Model with the View.</li>
 <li><h2>Router</h2>This is not mentioned in MVC letters but it's always there. Selecting the right controller is the responsibility of the router. The router 
 based on some rules knows what controller must be used according to the request. In ASP.NET MVC methods of a controller are called actions</li>
 </ul>
<p>With this architecture every component is responsible for doing something and seperating it for clearer code and maintanability.</p>
</section>

<section>
<h1>ASP.NET MVC structure</h1>

 <ul>
 <li><h2>App_Data</h2>Database files will be stored here</li>
 <li><h2>App_Start</h2>Includes some classes for when the application is started
	<ol>
		<li><h3>Routeconfig.cs</h3><p>This is the configuration or our routing rules.</p>
		<img src="route_config.jpg">
		<p>So if our url matches this patterns we have: First part is the name of the controller,second part is the name of the action, third part is an ID
		we can pass to that action. With this rule if we send a request to movies/popular in runtime we have a MoviesController and a Popular() method.
		Another example is with /movies/edit/1 we get MoviesController and its method Edit(int id) with id 1.
		</p>
		<p>Also we can see we have some defaults values in our picture. So if the request doesn't match the url pattern we will get the defaults.
		Similarly if we have the controller but not the action it will be handled by the Index action. If we go to /movies since we don't have any actions
		it will be handled by MoviesController.Index().
		</p>
		<p>Id is an optional parameter. Because not every action needs an id.</p>
		</li>
		
		<li><h3>Bundleconfig.cs</h3>
		<p>Here we define various bundles for client side assets like scripts css etc.</p>
		</li>
	</ol>
 </li>
 <li><h2>Content</h2>
 <p>Here we put our css files, images and every other client assets.</p>
 
 <li><h2>Controllers</h2>
 <p>The folder with our controllers which in our first created applcation we see 3 default controllers.</p>
 </li>
 
<li><h2>fonts</h2>
 <p>Fonts(we should move them to Content).</p>
 </li>
 
 <li><h2>Models</h2>
 <p>All our domain classes are here.</p>
 </li>
 
<li><h2>Scripts</h2>
 <p>Javascript files.</p>
</li>
 
<li><h2>Views</h2>
 <p>We have our views which is the V in MVC. In there we have folders named after controllers(without the ending controllers) in our application.
 By convention when we use a view ASP.NET will look for the same name as the controller.
 <img src="view.jpg">
 <p>We also have a folder called Shared which includes the views that can be viewed by different controllers.</p>
</li>

<li><h2>favicon.ico</h2>
 <p>The icon diplayed for our app in browser.</p>
</li>

<li><h2>Global.asax</h2>
 <p>Traditional file that has been in ASP.NET which is a class that provides hooks for various events in the applications lifecycle.
 When the application is started Global.asax will start. We will have some things registered like Routes.
 </p>
</li>

 <li><h2>packages.config</h2>
 <p>It's used by Nuget package manager(like npm bower etc). Instead of going to every site downloading and installing a package we have them all in one place 
 in Visual Studio.
 </p>
</li>
 
  <li><h2>Startup.cs</h2>
 <p>This the new approach microsft takes for ASP.NET core which will replace Global.asax when the application starts.
 </p>
</li>
 
   <li><h2>Web.config</h2>
 <p>This is an .xml file which has our configuration for our application. Mostly we use connectionStrings(database connection info) and appSettings(our configuration
 settings for our app)
 </p>
</li>
 
 </ul>


</section>

<section>
<h1>MVC in Action</h1>
<p>First we create a class in Model with the properties we want.</p>
<p>Let's say we want to have a page that we randomly pick a movie and render its details. If the page will be /movies/random we need to create a controller
called MoviesController with an action called random. So an action is a method responsible for handling a request.
</p>
<p>To create the controller in solution explorer right click in controller and then add controller. There we have some templates that will auto generate 
some code for us. Then we create an empty one. By default we have an Index action which returns the View. We have to create what methods/actions we will have.
 </p>
 <p>We have to say to this newlly created controller that we will use the models.
<img src="using_models_in_controller.jpg">
 </p>
 <p>As we see it returns the View which we should create in our folder Movies that will be called Random.
 <img src="add_view.jpg">
 </p>
 <p>There we can use a template and choose as a <strong>partial view</strong> which is like a widget which can be used on different views.
 <img src="partial_view.jpg">
 </p>
<p>Also we have to select the layout since we want all our pages look similar in our app. By default our mvc project has a layout to choose.
<img src="layout_template.jpg">

</p>

<h2>.cshtml(the view we created)</h2>
<ol>
<li><h3>ViewBag.Title </h3><p>This is basically the title for the page shown in the browser</p></li>
<li><h3>Layout</h3><p>The layout used for this view.</p></li>

</ol>
<p>Back at our MoviesController we pass the parameter we want to show in our View method.
<img src="return_view.jpg">
</p>

<p>When we want to write C#  and have it shown in our View we start with @. Then we write Model. Every View has 
this property which give us access to the Model we passed to it and the controller. If we type . at the Model we will see
that the type of this model is dynamic.
<img src="dynamic.jpg">
</p>
<p>On top of the file we need to use a directive to specify the type of the Model for this View.
<img src="fully_qualified_name.jpg">
</p>
<p>After that we can see that we can access the Name property for Model and we can put it in our html.</p>
</section>

<section>
<h1>ASP.NET MVC Fundamentals</h1>
<ul>

<li>
<h2>Action Results</h2>
<p>In our controllers before our methods name we have ActionResult type.</p>
<pre>        public ActionResult Random()
        {
            var movie = new Movie() {Name ="Shrek" };
            return View(movie);
        }</pre>
<p>ActionResult is the base class of all action resolves in ASP.NET MVC. Depending on what an action does it would return an instance of one the class that derives from.</p>		
</li>
<ol>
<li>
<h3>return View() in ActionResult</h3>
<p>This method allows us to quickly create a view result and derives from Controller class. Another way is :</p>
<pre>return new ViewResult();</pre>

</li>

<li>
<h3>ViewResult</h3>
<p>We can set the type to ViewResult instead of ActionResult. This is good for unit testing. Sometimes in an action we may have different execution paths and return different action results.</p>
</li>

<li>
<h3>PartialViewResult</h3>
<p>Return a PartialView().</p>
</li>

<li>
<h3>ContentResult</h3>
<p>Return simple text Content().</p>
<pre>   
        public ActionResult Random()
        {
            
            return Content("Hello World");
        }</pre>
</li>

<li>
<h3>RedirectResult</h3>
<p>Redirect user to url Redirect().</p>
</li>

<li>
<h3>RedirectToRouteResult</h3>
<p>RedirectToAction() instead of url. First the name of the action and then the name of the controller.</p>
<pre>        public ActionResult Random()
        {
            return RedirectToAction("Index","Home");
        }</pre>
		<p>If we want to have new query strings we will have to pass a third argument.
		<img src="query_strings.jpg"></p>
</li>

<li>
<h3>JsonResult</h3>
<p>Return a serialized object file Json().</p>
</li>

<li>
<h3>FileResult</h3>
<p>Return a  file File().</p>
</li>

<li>
<h3>HttpNotFoundResult</h3>
<p>Return a not found error HttpNotFound().</p>
<pre>        public ActionResult Random()
        {
            return HttpNotFound();
        }</pre>
</li>

<li>
<h3>EmptyResult</h3>
<p>Return something empty like void.</p>
<pre>        public ActionResult Random()
        {
            return new EmptyResult();
        }</pre>
</li>
</ol>

<li>
<h2>Action parameters</h2>
<p>The input for our actions. The parameter resources :</p>

<ol>
<li><p>In the URL : /movies/edit/1 (if the paramater is not named id but something else since in our default we must have it as id we will get an error)</p>
<img src="parameter_resource_url.jpg">
</li>
<li><p>In the query string : /movies/edit?id=2</p>
<img src="parameter_resource_query_string.jpg">
</li>
<li>In the form data : id=1</li>

<li><p>Optional parameter</p>
<pre>        public ActionResult Index(int? pageIndex,string sortBy)
        {
            if (!pageIndex.HasValue)
            {
                pageIndex = 1;
            }

            if (String.IsNullOrWhiteSpace(sortBy))
            {
                sortBy = "Name";
            }
            return Content(String.Format("pageIndex={0}&sortBy={1}", pageIndex, sortBy));

        }</pre>
</li>

</ol>

<p>If we don't have the parameter we will get an error.
<img src="no_parameter.jpg">
</p>
</li>


<li>
<h2>Convention-based Routing(custom Routing)</h2>
<p>We might need in our application more parameters than id like : /movies/released/2015/04. You have 
to define the Routes from the more specific to the most generic otherwise the more generic will be applied to the url.
The most common overload method is the one with three parameters(name,URL, defaults) and the name must be unique.
</p>
<pre>            routes.MapRoute(
                "MoviesByReleaseDate",
                "movies/released/{year/{month}}",
                new {controller = "Movies",action="ByReleaseDate"});</pre>
<p>Next we create the action(if we type mvcaction4 and tab we can create it fast). If the url doesn't matches the RouteConfig patterns we will get an error.
<img src="custom_routing.jpg">
</p>
<p>Regular Expression(if the url doesn't matches the expression we will get an error)</p>
<pre>            routes.MapRoute(
                "MoviesByReleaseDate",
                "movies/released/{year}/{month}",
                new{controller = "Movies",action="ByReleaseDate"},
                new {year = @"\d{4}", month = @"\d{2}"}
                );</pre>
<p>If we want to limit the route parameters: </p>
<pre>            routes.MapRoute(
                "MoviesByReleaseDate",
                "movies/released/{year}/{month}",
                new{controller = "Movies",action="ByReleaseDate"},
                new {year = @"2015||2016}", month = @"\d{2}"}
                );</pre>
</li>

<li><h2>Attribute Routing</h2>
<p>This is a cleaner way of creating custom routes so we can avoid making RouteConfig a mess and avoiding errors if we rename the action.</p>
<p>First we enable it:</p>
<pre>routes.MapMvcAttributeRoutes();</pre>
<p>And the way of not polluting our RouteConfig : </p>
<pre>        [Route("movies/released/{year}/{month:regex(\\d{2})}")]
        public ActionResult ByReleaseDate(int year,byte month)
        {
            return Content(year +"/" +month);
        }</pre>
		<h3>Constraints</h3>
		<ol>
		<li>range</li>
		<li>min</li>
		<li>max</li>
		<li>minlength</li>
		<li>maxlength</li>
		<li>int</li>
		<li>float</li>
		<li>guid</li>
		
		</ol>
</li>

<li><h2>Passing Data to Views</h2>
<p>We have two extra ways to return a view instead of only passing the parameter to View method.</p>
<h3>ViewData</h3>
<p>At our controller : </p>
<pre>        public ActionResult Random()
        {
            var movie = new Movie() { Name = "Shrek" };

            ViewData["Movie"] = movie;

            return View();
        }</pre>
		
<p>And at our Model we need to cast the ViewData with the type(this approach is ugly and shouldn't be used).</p>
<pre>@using Vidly.Models
@model Vidly.Models.Movie
@{
    ViewBag.Title = "Random";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

&lt;h2>@( ((Movie)ViewData["Movie"]).Name)&lt;/h2&gt;
</pre>
</li>

<li>
<p>Microsoft tried to fix it with ViewBag that instead of magic string it has a magic property. </p>
<pre>        public ActionResult Random()
        {
            var movie = new Movie() { Name = "Shrek" };

            ViewBag.Movie = movie;

            return View();
        }</pre>
<p>And at our View(if we decide to change it we should remember to change it at View also): </p>		
<pre>@using Vidly.Models
@model Vidly.Models.Movie
@{
    ViewBag.Title = "Random";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

&lt;h2>@ViewBag.Movie&lt;/h2></pre>
<h3>We should not use ViewData or ViewBag.</h3>
</li>


<li><h2>View Model</h2>
<p>A view model is a model specifically built for a view. It includes any data and rules specific to that view. For example if we
we didn't have the relation tou our model but we needed to show them in a view. </p>
<p>First we create a folder that will have our View Models. Then a class that will have the objects we want to relate.</p>
<img src="view_models.jpg">
<p>Then at our controller a viewModel :</p>
<pre>        public ActionResult Random()
        {
            var movie = new Movie() { Name = "Shrek" };
            var customers = new List&lt;Customer>
            {
                new Customer() {Name = "Customer1" },
                new Customer() {Name = "Customer2" }
            };

            var viewModel = new RandomMovieViewModel
            {
                Movie = movie,
                Customers = customers
            };

            return View(viewModel);
        }</pre>
<p>And at our Model : </p>
<pre>@model Vidly.ViewModels.RandomMovieViewModel

@{
    ViewBag.Title = "Random";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

&lt;h2>@Model.Movie.Name&lt;/h2></pre>

</li>

<li><h2>Razor Syntax - Razor Views</h2>
<p>We have seen that we simply add an @ symbol to write C# code in our View. We can alos write a foreach loop 
to show all data we want in our List. In the foreach block we can continue to write c# or we can write HTML.
</p>
<pre>@model Vidly.ViewModels.RandomMovieViewModel

@{
    ViewBag.Title = "Random";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

&lt;h2>@Model.Movie.Name&lt;/h2>

&lt;ul>
    @foreach (var customer in Model.Customers)
    {
        &lt;li>@customer.Name&lt;/li>
    }
&lt;/ul></pre>

<p>We can also write anything we want like ifs etc.</p>

<pre>@model Vidly.ViewModels.RandomMovieViewModel

@{
    ViewBag.Title = "Random";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

&lt;h2>@Model.Movie.Name&lt;/h2>

@if (Model.Customers.Count == 0)
{
    &lt;p>No one has rented this movei before.&lt;/p>
}</pre>

<p>Using if and else : </p>
<pre>@model Vidly.ViewModels.RandomMovieViewModel

@{
    ViewBag.Title = "Random";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

&lt;h2>@Model.Movie.Name&lt;/h2>

@if (Model.Customers.Count == 0)
{
    &lt;p>No one has rented this movei before.&lt;/p>
}
else
{
    &lt;ul>
        @foreach (var customer in Model.Customers)
        {
            &lt;li>@customer.Name&lt/li>
        }
    &lt;/ul>
}</pre>

<p><strong>Remember that type you pass in View of action result must be same in View:</strong></p>
<img src="type_controller_model.jpg">

<p>Rendering something dynamically : </p>
<pre>@{ 
    var className = Model.Customers.Count > 5 ? "popular" : null;
}

&lt;h2 class="@className">@Model.Movie.Name&lt/h2></pre>

<p>And to comment with razor syntax</p>
<pre>@*
    This is a comment
*@</pre>
</li>

<li>
<h2>Partial Views</h2>
<p>It's something that you can use it in different smaller areas like widgets etc or the navbar can be be in a partial view.
To create a partial view right click in views then add View. By convention we use an underscore for a partial view.
</p>
<img src="partial_views.jpg">
<p>Then to render it where we want we call the Html property of our Views.</p>
<pre>&lt;body>
    @Html.Partial("_NavBar")</pre>
</li>

<li><h3>ActionLink()</h3>
<p>ActionLink is used to define links for example in our navbar and has 9 overloads. In the below code we have
name of link, actionName, controllerName . </p>
<pre>                &lt;li>@Html.ActionLink("Home", "Index", "Home")&lt;/li></pre>



</li>

<li><h3>Url.Action()</h3>
<p>It provides only the Url potion and not the whole href like ActionLink(). </p>
<pre>&ltul>
    @foreach (var customer in Model.Customers)
    {
        &ltli>&lta href="@Url.Action("Details")/@customer.Id">@customer.Name&lt/a>&lt/li>
    }
&lt/ul></pre>



</li>

</ul>

</section>

<section>
<h1>Starting with database</h1>
<p>First in our package manager console we enable migrations.</p>
<p>Second we create our first migration with add-migration and name of migration.</p>
<p>Third we must create our tables in ApplicationContext as Dbset.</p>
<pre>    public class ApplicationDbContext : IdentityDbContext<ApplicationUser>
    {
        public DbSet<Customer> Customers { get; set; }

        public ApplicationDbContext()
            : base("DefaultConnection", throwIfV1Schema: false)
        {
        }

        public static ApplicationDbContext Create()
        {
            return new ApplicationDbContext();
        }
    }</pre>

<p>Forth we must generate our database by running the command update-database. We will have an mdf file created in our App-data :</p>
<img src="generating_database.jpg">
</section>

</body>
</html>